from typing import Any
from fa_paths import CONFIG
import re


class Config_Missing(ValueError):
    pass

class Conf_Editor:
    def __init__(self) -> None:
        self.unsaved=False
        self.inContext=False
    def load(self):
        if self.unsaved:
            raise RuntimeError("Unsaved Changes")
        if not self.inContext:
            raise RuntimeError("Not in context")
        section = ""
        self.c = (c:={section:""})
        with open(CONFIG,"r",newline='') as fp:
            for line in fp:
                if m:=re.match(r"(?m)^[ \t]*\[([^\r\n\]]+)\]",line):
                    section = m.group(1)
                    c[section]=""
                c[section]+=line
    def get_setting(self,section,setting):
        if not self.inContext:
            raise RuntimeError("Not in context")
        if m:=re.search(fr"(?m)^[ \t]*{setting}[ \t]*=(.*)",self.c[section]):
            return m.group(1).strip()
        if m:=re.search(fr"(?m)^[ \t]*;[ \t]*{setting}[ \t]*=(.*)",self.c[section]):
            return m.group(1).strip()
        raise Config_Missing(f"No {setting} setting found in {section} section.")
    def set_setting(self,section,setting,value,force=False):
        if not self.inContext:
            raise RuntimeError("Not in context")
        self.unsaved=True
        set_string=f"{setting}={value.strip()}\n"
        (self.c[section],n)=re.subn(fr"(?m)^[ \t]*{setting}[ \t]*=(.*)\r?\n",set_string,self.c[section])
        if n==1:
            return
        if n>1:
            raise ValueError(f"Duplicate setting [{setting}] found in section [{section}]")
        (self.c[section],n)=re.subn(fr"(?m)^[ \t]*;[ \t]*{setting}[ \t]*=(.*)\r?\n",set_string,self.c[section],count=1)
        if n==0:
            if not force:
                raise Config_Missing(f"Setting [{setting}] not found in section [{section}]")
            self.c[section]+=set_string
    def toggle(self,section,setting):
        val = self.get_setting(section,setting)
        val= 'true' if val == 'false' else 'false'
        self.set_setting(section,setting,val)
        return 0
    def save(self):
        if not self.inContext:
            raise RuntimeError("Not in context")
        with open(CONFIG,"w",newline='') as fp:
            for section in self.c.values():
                fp.write(section)
        self.unsaved=False
    def __enter__(self):
        if self.inContext:
            raise RuntimeError("config is already open")
        self.inContext=True
        self.load()
    def __exit__(self,exc_type, exc_val, exc_tb):
        if self.unsaved:
            self.save()
        self.inContext=False
    def __del__(self):
        if self.unsaved:
            raise RuntimeError("Unsaved Changes")





def __remake_section_names():
    from contextlib import redirect_stdout
    c=current_conf
    print(c.c.keys())
    with open('config_autogen.py','w') as fp:
        with redirect_stdout(fp):
            print(f"#file autogenerated by {__name__}.{__remake_section_names.__name__}")
            print("import config_helper as __ch")
            for k,text in c.c.items():
                class_name=k.replace('-','_')
                if not class_name:
                    if m:=re.search(r"\bversion=(.*)",text):
                        print(f"version={int(m.group(1))}")
                    continue
                print(f"class __{class_name}_h1(object):")
                for line in text.splitlines():
                    if m:= re.match(r'[ \t]*;?[ \t]*([\w-]+)[ \t]*=',line):
                        setting=m.group(1)
                        print(f"    {setting.replace('-','_'):20}=({repr(k)},{repr(setting)})")
                print(f"class __{class_name}_h2(__ch.my_awesome_getter_setter,__{class_name}_h1):")
                print("    pass")
                print(f"{class_name}=__{class_name}_h2()")
        

current_conf = Conf_Editor()

from config_autogen import *
with current_conf:
    conf_ver=int(current_conf.get_setting("","version"))
if version < conf_ver:
    print(f"Newer conf.ini version [{conf_ver}] detected. Please inform Factorio-Access maintainers.")

if __name__ == '__main__':
    __remake_section_names()
    #print(sound.alerts_volume)
    #sound.alerts_volume='0.65'
    #print(sound.alerts_volume)
    #current_conf.save()

